// Code generated by github.com/fjl/gencodec. DO NOT EDIT.

package core

import (
	"encoding/json"
	"math/big"

	"github.com/cypherium/cypher/common"
	"github.com/cypherium/cypher/common/hexutil"
	"github.com/cypherium/cypher/common/math"
	"github.com/cypherium/cypher/params"
)

var _ = (*keyGenesisSpecMarshaling)(nil)

// MarshalJSON marshals as JSON.
func (g GenesisKey) MarshalJSON() ([]byte, error) {
	type GenesisKey struct {
		Config        *params.ChainConfig                            `json:"config"`
		Version       string                                         `json:"version"`
		ParentHash    common.Hash                                    `json:"parentHash"`
		Nonce         math.HexOrDecimal64                            `json:"nonce"`
		Time          math.HexOrDecimal64                            `json:"timestamp"`
		ExtraData     string                                         `json:"extraData"`
		Number        math.HexOrDecimal64                            `json:"number"`
		Difficulty    *math.HexOrDecimal256                          `json:"difficulty" 			gencodec:"required"`
		MixHash       common.Hash                                    `json:"mixHash"`
		Alloc         map[common.UnprefixedAddress]GenesisKeyAccount `json:"alloc"      			gencodec:"required"`
		Signature     hexutil.Bytes                                  `json:"signatrue"`
		Exceptions    hexutil.Bytes                                  `json:"exceptions"`
		LeaderPubKey  string                                         `json:"leaderPubKey"`
		LeaderAddress string
		InPubKey      string `json:"inPubKey"            	gencodec:"required"`
		OutPubKey     string `json:"outPubKey"            	gencodec:"required"`
		InAddress     string `json:"inAddress"            	gencodec:"required"`
		OutAddress    string `json:"outAddress"            	gencodec:"required"`
	}
	var enc GenesisKey
	enc.Config = g.Config
	enc.Version = g.Version
	enc.ParentHash = g.ParentHash
	enc.Nonce = math.HexOrDecimal64(g.Nonce)
	enc.Time = math.HexOrDecimal64(g.Time)
	enc.ExtraData = g.ExtraData
	enc.Number = math.HexOrDecimal64(g.Number)
	enc.Difficulty = (*math.HexOrDecimal256)(g.Difficulty)
	enc.MixHash = g.MixHash
	if g.Alloc != nil {
		enc.Alloc = make(map[common.UnprefixedAddress]GenesisKeyAccount, len(g.Alloc))
		for k, v := range g.Alloc {
			enc.Alloc[common.UnprefixedAddress(k)] = v
		}
	}
	enc.Signature = g.Signature
	enc.Exceptions = g.Exceptions
	enc.LeaderPubKey = g.LeaderPubKey
	enc.LeaderAddress = g.LeaderAddress
	enc.InPubKey = g.InPubKey
	enc.OutPubKey = g.OutPubKey
	enc.InAddress = g.InAddress
	enc.OutAddress = g.OutAddress
	return json.Marshal(&enc)
}

// UnmarshalJSON unmarshals from JSON.
func (g *GenesisKey) UnmarshalJSON(input []byte) error {
	type GenesisKey struct {
		Config        *params.ChainConfig                            `json:"config"`
		Version       *string                                        `json:"version"`
		ParentHash    *common.Hash                                   `json:"parentHash"`
		Nonce         *math.HexOrDecimal64                           `json:"nonce"`
		Time          *math.HexOrDecimal64                           `json:"timestamp"`
		ExtraData     *string                                        `json:"extraData"`
		Number        *math.HexOrDecimal64                           `json:"number"`
		Difficulty    *math.HexOrDecimal256                          `json:"difficulty" 			gencodec:"required"`
		MixHash       *common.Hash                                   `json:"mixHash"`
		Alloc         map[common.UnprefixedAddress]GenesisKeyAccount `json:"alloc"      			gencodec:"required"`
		Signature     *hexutil.Bytes                                 `json:"signatrue"`
		Exceptions    *hexutil.Bytes                                 `json:"exceptions"`
		LeaderPubKey  *string                                        `json:"leaderPubKey"`
		LeaderAddress *string
		InPubKey      *string `json:"inPubKey"            	gencodec:"required"`
		OutPubKey     *string `json:"outPubKey"            	gencodec:"required"`
		InAddress     *string `json:"inAddress"            	gencodec:"required"`
		OutAddress    *string `json:"outAddress"            	gencodec:"required"`
	}
	var dec GenesisKey
	if err := json.Unmarshal(input, &dec); err != nil {
		return err
	}
	if dec.Config != nil {
		g.Config = dec.Config
	}
	if dec.Version != nil {
		g.Version = *dec.Version
	}
	if dec.ParentHash != nil {
		g.ParentHash = *dec.ParentHash
	}
	if dec.Nonce != nil {
		g.Nonce = uint64(*dec.Nonce)
	}
	if dec.Time != nil {
		g.Time = uint64(*dec.Time)
	}
	if dec.ExtraData != nil {
		g.ExtraData = *dec.ExtraData
	}
	if dec.Number != nil {
		g.Number = uint64(*dec.Number)
	}
	if dec.Difficulty != nil {
		g.Difficulty = (*big.Int)(dec.Difficulty)
	}
	if dec.MixHash != nil {
		g.MixHash = *dec.MixHash
	}
	if dec.Alloc != nil {
		g.Alloc = make(KeyGenesisAlloc, len(dec.Alloc))
		for k, v := range dec.Alloc {
			g.Alloc[common.Address(k)] = v
		}
	}
	if dec.Signature != nil {
		g.Signature = *dec.Signature
	}
	if dec.Exceptions != nil {
		g.Exceptions = *dec.Exceptions
	}
	if dec.LeaderPubKey != nil {
		g.LeaderPubKey = *dec.LeaderPubKey
	}
	if dec.LeaderAddress != nil {
		g.LeaderAddress = *dec.LeaderAddress
	}
	if dec.InPubKey != nil {
		g.InPubKey = *dec.InPubKey
	}
	if dec.OutPubKey != nil {
		g.OutPubKey = *dec.OutPubKey
	}
	if dec.InAddress != nil {
		g.InAddress = *dec.InAddress
	}
	if dec.OutAddress != nil {
		g.OutAddress = *dec.OutAddress
	}
	return nil
}
